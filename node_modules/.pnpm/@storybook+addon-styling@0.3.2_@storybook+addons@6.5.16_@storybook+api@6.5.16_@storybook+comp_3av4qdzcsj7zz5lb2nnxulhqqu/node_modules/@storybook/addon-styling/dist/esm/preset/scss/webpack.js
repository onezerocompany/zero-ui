function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var isRuleForSCSS = function isRuleForSCSS(rule) {
  return typeof rule !== "string" && rule.test instanceof RegExp && (rule.test.test("test.scss") || rule.test.test("test.sass"));
};

var buildStyleLoader = function buildStyleLoader(options) {
  return {
    loader: "style-loader"
  };
};

var buildCssLoader = function buildCssLoader(_ref) {
  var cssModules = _ref.cssModules,
      postCss = _ref.postCss;
  var importSettings = {
    importLoaders: postCss ? 3 : 2
  };
  var moduleSettings = cssModules ? {
    modules: "auto"
  } : {};
  return {
    loader: "css-loader",
    options: _objectSpread(_objectSpread({}, importSettings), moduleSettings)
  };
};

var buildPostCssLoader = function buildPostCssLoader(_ref2) {
  var postCss = _ref2.postCss;
  var implementationOptions = _typeof(postCss) === "object" ? _objectSpread({}, postCss) : {};
  return {
    loader: "postcss-loader",
    options: _objectSpread({}, implementationOptions)
  };
};

var buildUrlResolverLoader = function buildUrlResolverLoader(options) {
  return {
    loader: "resolve-url-loader"
  };
};

var buildSassLoader = function buildSassLoader(_ref3) {
  var sass = _ref3.sass;
  var sassOptions = _typeof(sass) === "object" ? {
    sassOptions: sass
  } : {};
  var implementationOptions = _typeof(sass) === "object" && sass.hasOwnProperty("implementation") ? // @ts-expect-error
  {
    implementation: sass.implementation
  } : {};
  var additionalData = _typeof(sass) === "object" && (sass.hasOwnProperty("prependData") || sass.hasOwnProperty("additionalData")) ? // @ts-expect-error
  {
    additionalData: sass.prependData || sass.additionalData
  } : {};
  return {
    loader: "sass-loader",
    options: _objectSpread(_objectSpread(_objectSpread({
      sourceMap: true
    }, sassOptions), implementationOptions), additionalData)
  };
};

var SCSS_FILE_REGEX = /\.s[ac]ss$/;

var buildScssRule = function buildScssRule(options) {
  if (options.scssBuildRule) return options.scssBuildRule;
  var buildRule = [buildStyleLoader(options), buildCssLoader(options)].concat(_toConsumableArray(options.postCss ? [buildPostCssLoader(options)] : []), [buildUrlResolverLoader(options), buildSassLoader(options)]);
  return {
    test: SCSS_FILE_REGEX,
    use: buildRule
  };
};

export var patchOrAddScssRule = function patchOrAddScssRule(config, options) {
  var _config$module;

  // If the user doesn't want to patch webpack for postcss or css modules
  if (!options.cssModules && !options.postCss && !options.sass && !options.scssBuildRule) {
    // return without adjusting config
    return;
  }

  var rules = (_config$module = config.module) === null || _config$module === void 0 ? void 0 : _config$module.rules;
  var rule = buildScssRule(options);
  var ruleIndex = rules === null || rules === void 0 ? void 0 : rules.findIndex(isRuleForSCSS);

  if (ruleIndex === -1) {
    // If no existing css rule, add it
    rules === null || rules === void 0 ? void 0 : rules.push(rule);
  } else {
    // If existing css rule, replace it
    rules[ruleIndex] = rule;
  }
};